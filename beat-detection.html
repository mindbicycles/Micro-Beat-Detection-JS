<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Beat Detection</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: 'Courier New', monospace;
            background: #000;
            color: #0f0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
        }

        #beatVisualizer {
            width: 400px;
            height: 400px;
            border-radius: 50%;
            background: radial-gradient(circle, #001100, #000000);
            box-shadow: 0 0 50px rgba(0, 255, 0, 0.3);
            transition: all 0.1s ease-out;
            margin: 20px 0;
        }

        #beatVisualizer.beat {
            box-shadow: 0 0 100px rgba(0, 255, 0, 1);
        }

        button {
            background: #003300;
            color: #0f0;
            border: 2px solid #0f0;
            padding: 15px 30px;
            font-size: 18px;
            font-family: inherit;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
        }

        button:hover {
            background: #005500;
            box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
        }

        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        #console {
            width: 100%;
            max-width: 800px;
            height: 200px;
            overflow-y: auto;
            background: #001100;
            border: 1px solid #0f0;
            padding: 10px;
            margin-top: 20px;
            font-size: 12px;
            line-height: 1.4;
        }

        .metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 10px;
            width: 100%;
            max-width: 800px;
            margin: 20px 0;
        }

        .metric {
            background: #001100;
            border: 1px solid #0f0;
            padding: 10px;
        }

        .progress-bar {
            height: 20px;
            background: #002200;
            margin: 5px 0;
            position: relative;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: #0f0;
            transition: width 0.1s;
        }

        h1 {
            text-align: center;
            text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
        }

        #status {
            color: #ff0;
        }
    </style>
</head>
<body>
    <h1>Micro Beat Detection</h1>
    <div id="status">Click "Start" to begin</div>

    <div id="beatVisualizer"></div>

    <div>
        <button id="startBtn">Start</button>
        <button id="stopBtn" disabled>Stop</button>
    </div>

    <div class="metrics">
        <div class="metric">
            <div>Signal</div>
            <div class="progress-bar"><div id="signalBar" class="progress-fill"></div></div>
        </div>
        <div class="metric">
            <div>Beat Probability</div>
            <div class="progress-bar"><div id="beatProbBar" class="progress-fill"></div></div>
        </div>
        <div class="metric">
            <div>Signal Change</div>
            <div class="progress-bar"><div id="signalChangeBar" class="progress-fill"></div></div>
        </div>
        <div class="metric">
            <div>Magnitude Change</div>
            <div class="progress-bar"><div id="magChangeBar" class="progress-fill"></div></div>
        </div>
        <div class="metric">
            <div>Variance</div>
            <div class="progress-bar"><div id="varianceBar" class="progress-fill"></div></div>
        </div>
        <div class="metric">
            <div>Light Intensity</div>
            <div class="progress-bar"><div id="lightBar" class="progress-fill"></div></div>
        </div>
    </div>

    <div id="console"></div>

    <script>
        // Constants
        const FFT_SIZE = 256;
        const FREQUENCY_MAGNITUDE_SAMPLES = 5;
        const MAXIMUM_SIGNAL_VALUE = 255;

        const OVERALL_FREQUENCY_RANGE_START = 2;
        const OVERALL_FREQUENCY_RANGE_END = FFT_SIZE / 4;

        const FIRST_FREQUENCY_RANGE_START = 2;
        const FIRST_FREQUENCY_RANGE_END = 8;

        const SECOND_FREQUENCY_RANGE_START = 2;
        const SECOND_FREQUENCY_RANGE_END = 12;

        const MAXIMUM_BEATS_PER_MINUTE = 200;
        const MINIMUM_DELAY_BETWEEN_BEATS = 60000 / MAXIMUM_BEATS_PER_MINUTE;
        const SINGLE_BEAT_DURATION = 100;

        const LIGHT_FADE_OUT_DURATION = 500;
        const MINIMUM_LIGHT_INTENSITY = 0.1;
        const MAXIMUM_LIGHT_INTENSITY = 1.0;

        const BEAT_PROBABILITY_THRESHOLD = 0.5;

        // State variables
        let audioContext;
        let analyser;
        let microphone;
        let dataArray;
        let animationId;

        let frequencyMagnitudeSampleIndex = 0;

        let currentOverallFrequencyMagnitude = 0;
        let totalOverallFrequencyMagnitude = 0;
        let averageOverallFrequencyMagnitude = 0;
        let overallFrequencyMagnitudeVariance = 0;
        let overallFrequencyMagnitudes = new Array(FREQUENCY_MAGNITUDE_SAMPLES).fill(0);

        let currentFirstFrequencyMagnitude = 0;
        let totalFirstFrequencyMagnitude = 0;
        let averageFirstFrequencyMagnitude = 0;
        let firstFrequencyMagnitudeVariance = 0;
        let firstFrequencyMagnitudes = new Array(FREQUENCY_MAGNITUDE_SAMPLES).fill(0);

        let currentSecondFrequencyMagnitude = 0;
        let totalSecondFrequencyMagnitude = 0;
        let averageSecondFrequencyMagnitude = 0;
        let secondFrequencyMagnitudeVariance = 0;
        let secondFrequencyMagnitudes = new Array(FREQUENCY_MAGNITUDE_SAMPLES).fill(0);

        let currentSignal = 0;
        let totalSignal = 0;
        let averageSignal = 0;
        let signalVariance = 0;
        let signals = new Array(FREQUENCY_MAGNITUDE_SAMPLES).fill(0);

        let lastBeatTimestamp = 0;
        let durationSinceLastBeat = 0;
        let beatProbability = 0;

        let lightIntensityBumpTimestamp = 0;
        let lightIntensityBumpValue = 0;
        let lightIntensityValue = 0;

        // UI Elements
        const startBtn = document.getElementById('startBtn');
        const stopBtn = document.getElementById('stopBtn');
        const status = document.getElementById('status');
        const consoleDiv = document.getElementById('console');
        const beatVisualizer = document.getElementById('beatVisualizer');

        // Event Listeners
        startBtn.addEventListener('click', start);
        stopBtn.addEventListener('click', stop);

        async function start() {
            try {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                analyser.fftSize = FFT_SIZE;
                analyser.smoothingTimeConstant = 0;

                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                microphone = audioContext.createMediaStreamSource(stream);
                microphone.connect(analyser);

                dataArray = new Uint8Array(analyser.frequencyBinCount);

                startBtn.disabled = true;
                stopBtn.disabled = false;
                status.textContent = 'Running...';
                status.style.color = '#0f0';

                log('Beat detection started');
                loop();
            } catch (error) {
                log('Error: ' + error.message);
                status.textContent = 'Error: ' + error.message;
                status.style.color = '#f00';
            }
        }

        function stop() {
            if (animationId) {
                cancelAnimationFrame(animationId);
            }
            if (microphone) {
                microphone.disconnect();
                microphone.mediaStream.getTracks().forEach(track => track.stop());
            }
            if (audioContext) {
                audioContext.close();
            }

            startBtn.disabled = false;
            stopBtn.disabled = true;
            status.textContent = 'Stopped';
            status.style.color = '#ff0';

            log('Beat detection stopped');
        }

        function loop() {
            animationId = requestAnimationFrame(loop);

            readAudioSamples();
            getFrequencyData();
            processFrequencyData();
            updateBeatProbability();
            updateLightIntensityBasedOnBeats();
            updateVisuals();
        }

        function readAudioSamples() {
            analyser.getByteTimeDomainData(dataArray);

            let currentAverage = 0;
            let currentMaximum = 0;
            let currentMinimum = MAXIMUM_SIGNAL_VALUE;

            for (let i = 0; i < dataArray.length; i++) {
                const value = dataArray[i];
                currentMinimum = Math.min(currentMinimum, value);
                currentMaximum = Math.max(currentMaximum, value);
                currentAverage += value;
            }

            currentAverage /= dataArray.length;

            const signalDelta = currentMaximum - currentAverage;
            currentSignal = currentAverage + (2 * signalDelta);
            currentSignal = Math.max(0, Math.min(MAXIMUM_SIGNAL_VALUE, currentSignal));

            processHistoryValues(
                signals,
                currentSignal,
                'signal'
            );
        }

        function getFrequencyData() {
            analyser.getByteFrequencyData(dataArray);
        }

        function processFrequencyData() {
            processOverallFrequencyMagnitude();
            processFirstFrequencyMagnitude();
            processSecondFrequencyMagnitude();

            frequencyMagnitudeSampleIndex++;
            if (frequencyMagnitudeSampleIndex >= FREQUENCY_MAGNITUDE_SAMPLES) {
                frequencyMagnitudeSampleIndex = 0;
            }
        }

        function processOverallFrequencyMagnitude() {
            currentOverallFrequencyMagnitude = getFrequencyMagnitude(
                OVERALL_FREQUENCY_RANGE_START,
                OVERALL_FREQUENCY_RANGE_END
            );

            processHistoryValues(
                overallFrequencyMagnitudes,
                currentOverallFrequencyMagnitude,
                'overall'
            );
        }

        function processFirstFrequencyMagnitude() {
            currentFirstFrequencyMagnitude = getFrequencyMagnitude(
                FIRST_FREQUENCY_RANGE_START,
                FIRST_FREQUENCY_RANGE_END
            );

            processHistoryValues(
                firstFrequencyMagnitudes,
                currentFirstFrequencyMagnitude,
                'first'
            );
        }

        function processSecondFrequencyMagnitude() {
            currentSecondFrequencyMagnitude = getFrequencyMagnitude(
                SECOND_FREQUENCY_RANGE_START,
                SECOND_FREQUENCY_RANGE_END
            );

            processHistoryValues(
                secondFrequencyMagnitudes,
                currentSecondFrequencyMagnitude,
                'second'
            );
        }

        function getFrequencyMagnitude(startIndex, endIndex) {
            let total = 0;
            let maximum = 0;
            let minimum = MAXIMUM_SIGNAL_VALUE;

            for (let i = startIndex; i < endIndex && i < dataArray.length; i++) {
                const current = dataArray[i];
                total += current;
                maximum = Math.max(maximum, current);
                minimum = Math.min(minimum, current);
            }

            const average = total / (endIndex - startIndex);
            return average;
        }

        function processHistoryValues(history, current, type) {
            history[frequencyMagnitudeSampleIndex] = current;

            let total = 0;
            for (let i = 0; i < FREQUENCY_MAGNITUDE_SAMPLES; i++) {
                total += history[i];
            }
            const average = total / FREQUENCY_MAGNITUDE_SAMPLES;

            let squaredDifferenceSum = 0;
            for (let i = 0; i < FREQUENCY_MAGNITUDE_SAMPLES; i++) {
                squaredDifferenceSum += Math.pow(history[i] - average, 2);
            }
            const variance = squaredDifferenceSum / FREQUENCY_MAGNITUDE_SAMPLES;

            switch(type) {
                case 'signal':
                    totalSignal = total;
                    averageSignal = average;
                    signalVariance = variance;
                    break;
                case 'overall':
                    totalOverallFrequencyMagnitude = total;
                    averageOverallFrequencyMagnitude = average;
                    overallFrequencyMagnitudeVariance = variance;
                    break;
                case 'first':
                    totalFirstFrequencyMagnitude = total;
                    averageFirstFrequencyMagnitude = average;
                    firstFrequencyMagnitudeVariance = variance;
                    break;
                case 'second':
                    totalSecondFrequencyMagnitude = total;
                    averageSecondFrequencyMagnitude = average;
                    secondFrequencyMagnitudeVariance = variance;
                    break;
            }
        }

        function updateBeatProbability() {
            beatProbability = 1;
            const signalChangeFactor = calculateSignalChangeFactor();
            const magnitudeChangeFactor = calculateMagnitudeChangeFactor();
            const varianceFactor = calculateVarianceFactor();
            const recencyFactor = calculateRecencyFactor();

            beatProbability *= signalChangeFactor;
            beatProbability *= magnitudeChangeFactor;
            beatProbability *= varianceFactor;
            beatProbability *= recencyFactor;

            if (beatProbability >= BEAT_PROBABILITY_THRESHOLD) {
                lastBeatTimestamp = Date.now();
                durationSinceLastBeat = 0;
                onBeatDetected();
            }

            updateProgressBar('beatProbBar', beatProbability);
        }

        function calculateSignalChangeFactor() {
            let aboveAverageSignalFactor;
            if (averageSignal < 75 || currentSignal < 150) {
                aboveAverageSignalFactor = 0;
            } else {
                aboveAverageSignalFactor = currentSignal / averageSignal;
                aboveAverageSignalFactor = Math.max(0, Math.min(2, aboveAverageSignalFactor));
            }

            updateProgressBar('signalChangeBar', aboveAverageSignalFactor / 2);
            return aboveAverageSignalFactor;
        }

        function calculateMagnitudeChangeFactor() {
            let changeThresholdFactor = 1.1;
            if (durationSinceLastBeat < 750) {
                changeThresholdFactor *= 0.95;
            } else if (durationSinceLastBeat > 1000) {
                changeThresholdFactor *= 1.05;
            }

            let aboveAverageOverallMagnitudeFactor = currentOverallFrequencyMagnitude / averageOverallFrequencyMagnitude;
            aboveAverageOverallMagnitudeFactor -= 1.05;
            aboveAverageOverallMagnitudeFactor *= 10;
            aboveAverageOverallMagnitudeFactor = Math.max(0, Math.min(1, aboveAverageOverallMagnitudeFactor));

            let aboveAverageFirstMagnitudeFactor = currentFirstFrequencyMagnitude / averageFirstFrequencyMagnitude;
            aboveAverageFirstMagnitudeFactor -= 0.1;
            aboveAverageFirstMagnitudeFactor *= 1.5;
            aboveAverageFirstMagnitudeFactor = Math.pow(aboveAverageFirstMagnitudeFactor, 3);
            aboveAverageFirstMagnitudeFactor /= 3;
            aboveAverageFirstMagnitudeFactor -= 1.25;
            aboveAverageFirstMagnitudeFactor = Math.max(0, Math.min(1, aboveAverageFirstMagnitudeFactor));

            let aboveAverageSecondMagnitudeFactor = currentSecondFrequencyMagnitude / averageSecondFrequencyMagnitude;
            aboveAverageSecondMagnitudeFactor -= 1.01;
            aboveAverageSecondMagnitudeFactor *= 10;
            aboveAverageSecondMagnitudeFactor = Math.max(0, Math.min(1, aboveAverageSecondMagnitudeFactor));

            let magnitudeChangeFactor = aboveAverageFirstMagnitudeFactor;
            if (magnitudeChangeFactor > 0.15) {
                magnitudeChangeFactor = Math.max(aboveAverageFirstMagnitudeFactor, aboveAverageSecondMagnitudeFactor);
            }

            if (magnitudeChangeFactor < 0.5 && aboveAverageOverallMagnitudeFactor > 0.5) {
                magnitudeChangeFactor = Math.max(magnitudeChangeFactor, aboveAverageOverallMagnitudeFactor);
            }

            updateProgressBar('magChangeBar', magnitudeChangeFactor);
            return magnitudeChangeFactor;
        }

        function calculateVarianceFactor() {
            let firstVarianceFactor = ((firstFrequencyMagnitudeVariance - 50) / 20) - 1;
            firstVarianceFactor = Math.max(0, Math.min(1, firstVarianceFactor));

            let secondVarianceFactor = ((secondFrequencyMagnitudeVariance - 50) / 20) - 1;
            secondVarianceFactor = Math.max(0, Math.min(1, secondVarianceFactor));

            const varianceFactor = Math.max(firstVarianceFactor, secondVarianceFactor);

            updateProgressBar('varianceBar', varianceFactor);
            return varianceFactor;
        }

        function calculateRecencyFactor() {
            durationSinceLastBeat = Date.now() - lastBeatTimestamp;

            const referenceDuration = MINIMUM_DELAY_BETWEEN_BEATS - SINGLE_BEAT_DURATION;
            let recencyFactor = 1 - (referenceDuration / durationSinceLastBeat);
            recencyFactor = Math.max(0, Math.min(1, recencyFactor));

            return recencyFactor;
        }

        function updateLightIntensityBasedOnBeats() {
            let intensity = 1 - (durationSinceLastBeat / LIGHT_FADE_OUT_DURATION);
            intensity = Math.max(0, Math.min(1, intensity));

            if (intensity > lightIntensityValue) {
                lightIntensityBumpValue = intensity;
                lightIntensityBumpTimestamp = Date.now();
            }
        }

        function updateVisuals() {
            const durationSinceLastBump = Date.now() - lightIntensityBumpTimestamp;
            let fadeFactor = 1 - (durationSinceLastBump / LIGHT_FADE_OUT_DURATION);
            fadeFactor = Math.max(0, Math.min(1, fadeFactor));

            lightIntensityValue = lightIntensityBumpValue * fadeFactor;
            lightIntensityValue = Math.max(0, Math.min(1, lightIntensityValue));

            const scaledLightIntensity = MINIMUM_LIGHT_INTENSITY +
                (lightIntensityValue * (MAXIMUM_LIGHT_INTENSITY - MINIMUM_LIGHT_INTENSITY));

            beatVisualizer.style.background = `radial-gradient(circle,
                rgba(0, ${Math.floor(255 * scaledLightIntensity)}, 0, ${scaledLightIntensity}),
                #000000)`;
            beatVisualizer.style.boxShadow = `0 0 ${50 + scaledLightIntensity * 150}px rgba(0, 255, 0, ${scaledLightIntensity})`;

            updateProgressBar('signalBar', currentSignal / MAXIMUM_SIGNAL_VALUE);
            updateProgressBar('lightBar', lightIntensityValue);
        }

        function onBeatDetected() {
            beatVisualizer.classList.add('beat');
            setTimeout(() => beatVisualizer.classList.remove('beat'), 100);
            log('BEAT DETECTED!');
        }

        function updateProgressBar(id, value) {
            const bar = document.getElementById(id);
            if (bar) {
                bar.style.width = (value * 100) + '%';
            }
        }

        function log(message) {
            const timestamp = new Date().toLocaleTimeString();
            consoleDiv.innerHTML += `[${timestamp}] ${message}<br>`;
            consoleDiv.scrollTop = consoleDiv.scrollHeight;
        }
    </script>
</body>
</html>
