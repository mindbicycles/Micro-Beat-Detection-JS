<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Beat Detection</title>
    <style>
      body {
        margin: 0;
        padding: 20px;
        font-family: "Courier New", monospace;
        background: #000;
        color: #0f0;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        min-height: 100vh;
      }

      #beatVisualizer {
        width: 400px;
        height: 400px;
        border-radius: 50%;
        background: radial-gradient(circle, #001100, #000000);
        box-shadow: 0 0 50px rgba(0, 255, 0, 0.3);
        transition: all 0.1s ease-out;
        margin: 20px 0;
      }

      #beatVisualizer.beat {
        box-shadow: 0 0 100px rgba(0, 255, 0, 1);
      }

      /* Additional visualizers for first and second frequency bands */
      #firstBeatVisualizer,
      #secondBeatVisualizer {
        width: 200px;
        height: 200px;
        border-radius: 50%;
        background: radial-gradient(circle, #001100, #000000);
        box-shadow: 0 0 30px rgba(0, 255, 0, 0.3);
        transition: all 0.1s ease-out;
        margin: 10px;
        display: inline-block;
      }

      #firstBeatVisualizer.beat,
      #secondBeatVisualizer.beat {
        box-shadow: 0 0 60px rgba(0, 255, 0, 1);
      }

      .visualizer-row {
        display: flex;
        gap: 20px;
        align-items: center;
        justify-content: center;
        flex-wrap: wrap;
      }

      .visualizer-item {
        display: flex;
        flex-direction: column;
        align-items: center;
      }

      .viz-label {
        margin-top: 8px;
        font-size: 14px;
        color: #0f0;
        opacity: 0.8;
      }

      /* Mini progress bars for band beat probabilities */
      .mini-progress {
        width: 140px;
        height: 6px;
        background: #002200;
        border: 1px solid #0f0;
        margin-top: 6px;
        overflow: hidden;
      }

      .mini-fill {
        height: 100%;
        background: #0f0;
        width: 0%;
        transition: width 0.1s;
      }

      button {
        background: #003300;
        color: #0f0;
        border: 2px solid #0f0;
        padding: 15px 30px;
        font-size: 18px;
        font-family: inherit;
        cursor: pointer;
        margin: 10px;
        transition: all 0.3s;
      }

      button:hover {
        background: #005500;
        box-shadow: 0 0 20px rgba(0, 255, 0, 0.5);
      }

      button:disabled {
        opacity: 0.5;
        cursor: not-allowed;
      }

      #console {
        width: 100%;
        max-width: 800px;
        height: 200px;
        overflow-y: auto;
        background: #001100;
        border: 1px solid #0f0;
        padding: 10px;
        margin-top: 20px;
        font-size: 12px;
        line-height: 1.4;
      }

      .metrics {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        width: 100%;
        max-width: 800px;
        margin: 20px 0;
      }

      .metric {
        background: #001100;
        border: 1px solid #0f0;
        padding: 10px;
      }

      .progress-bar {
        height: 20px;
        background: #002200;
        margin: 5px 0;
        position: relative;
        overflow: hidden;
      }

      .progress-fill {
        height: 100%;
        background: #0f0;
        transition: width 0.1s;
      }

      h1 {
        text-align: center;
        text-shadow: 0 0 10px rgba(0, 255, 0, 0.5);
      }

      #status {
        color: #ff0;
      }
    </style>
  </head>
  <body>
    <h1>Micro Beat Detection</h1>
    <div id="status">Click "Start" to begin</div>

    <div class="visualizer-item">
      <div id="beatVisualizer"></div>
      <div class="viz-label">Overall</div>
    </div>

    <div class="visualizer-row">
      <div class="visualizer-item">
        <div id="firstBeatVisualizer"></div>
        <div class="viz-label">Low</div>
        <div class="mini-progress">
          <div id="beatProbBarFirstSmall" class="mini-fill"></div>
        </div>
      </div>
      <div class="visualizer-item">
        <div id="secondBeatVisualizer"></div>
        <div class="viz-label">Mid</div>
        <div class="mini-progress">
          <div id="beatProbBarSecondSmall" class="mini-fill"></div>
        </div>
      </div>
    </div>

    <div>
      <button id="startBtn">Start</button>
      <button id="stopBtn" disabled>Stop</button>
    </div>

    <div class="metrics">
      <div class="metric">
        <div>Signal</div>
        <div class="progress-bar">
          <div id="signalBar" class="progress-fill"></div>
        </div>
      </div>
      <div class="metric">
        <div>Beat Probability</div>
        <div class="progress-bar">
          <div id="beatProbBar" class="progress-fill"></div>
        </div>
      </div>
      <div class="metric">
        <div>Signal Change</div>
        <div class="progress-bar">
          <div id="signalChangeBar" class="progress-fill"></div>
        </div>
      </div>
      <div class="metric">
        <div>Magnitude Change</div>
        <div class="progress-bar">
          <div id="magChangeBar" class="progress-fill"></div>
        </div>
      </div>
      <div class="metric">
        <div>Variance</div>
        <div class="progress-bar">
          <div id="varianceBar" class="progress-fill"></div>
        </div>
      </div>
      <div class="metric">
        <div>Light Intensity</div>
        <div class="progress-bar">
          <div id="lightBar" class="progress-fill"></div>
        </div>
      </div>
      <div class="metric">
        <div>Band Thresholds</div>
        <label style="display: block; margin-top: 6px"
          >Low Threshold
          <input
            id="firstThreshold"
            type="range"
            min="0"
            max="1"
            step="0.01"
            value="0.5"
          />
        </label>
        <label style="display: block; margin-top: 6px"
          >Mid Threshold
          <input
            id="secondThreshold"
            type="range"
            min="0"
            max="1"
            step="0.01"
            value="0.5"
          />
        </label>
      </div>
    </div>

    <div id="console"></div>

    <script>
      // Constants
      // Size of the FFT used by the Web Audio `AnalyserNode`.
      // Larger sizes provide finer frequency resolution but increase latency;
      // 256 balances responsiveness and resolution for real-time beat detection.
      const FFT_SIZE = 256;

      // Number of recent samples used for rolling averages/variance.
      // Acts as the window length for smoothing signal and band magnitudes.
      const FREQUENCY_MAGNITUDE_SAMPLES = 5;
      // Max value returned by `getByteTimeDomainData` / `getByteFrequencyData` (0–255).
      // Used to clamp computed signal metrics to the valid byte range.
      const MAXIMUM_SIGNAL_VALUE = 255;

      // Minimum probability required to register a beat.
      // The combined factors (signal change, magnitude change, variance, recency)
      // must exceed this threshold to trigger a beat event.
      const BEAT_PROBABILITY_THRESHOLD = 0.5;

      // Indices (FFT bins) for an "overall" low–mid frequency band.
      // Start at 2 to skip DC/very-low noise; end at FFT_SIZE/4 to focus on
      // beat-relevant bands (with `frequencyBinCount = FFT_SIZE/2`).
      const OVERALL_FREQUENCY_RANGE_START = 2;
      const OVERALL_FREQUENCY_RANGE_END = FFT_SIZE / 4;

      // Narrow low-frequency band emphasizing kick/transient energy.
      // Used in `calculateMagnitudeChangeFactor()` as a primary beat cue.
      const FIRST_FREQUENCY_RANGE_START = 2;
      const FIRST_FREQUENCY_RANGE_END = 8;

      // Slightly wider low–mid band to capture additional rhythmic energy.
      // Combined with the first band to reduce false negatives.
      const SECOND_FREQUENCY_RANGE_START = 2;
      const SECOND_FREQUENCY_RANGE_END = 12;

      // Upper bound for tempo used to gate detections (anti-double counting).
      // At 200 BPM, the minimum interval between beats is 300 ms.
      const MAXIMUM_BEATS_PER_MINUTE = 200;
      // Derived minimum inter-beat interval, used in the recency factor to avoid
      // detecting beats too close together.
      const MINIMUM_DELAY_BETWEEN_BEATS = 60000 / MAXIMUM_BEATS_PER_MINUTE;
      // Approximate duration of a single beat event (ms) used to time the
      // visual pulse and adjust the recency weighting.
      const SINGLE_BEAT_DURATION = 100;

      const LIGHT_FADE_OUT_DURATION = 500;
      const MINIMUM_LIGHT_INTENSITY = 0.1;
      const MAXIMUM_LIGHT_INTENSITY = 1.0;

      // State variables
      let audioContext;
      let analyser;
      let microphone;
      let dataArray;
      let animationId;

      let frequencyMagnitudeSampleIndex = 0;

      let currentOverallFrequencyMagnitude = 0;
      let totalOverallFrequencyMagnitude = 0;
      let averageOverallFrequencyMagnitude = 0;
      let overallFrequencyMagnitudeVariance = 0;
      let overallFrequencyMagnitudes = new Array(
        FREQUENCY_MAGNITUDE_SAMPLES
      ).fill(0);

      let currentFirstFrequencyMagnitude = 0;
      let totalFirstFrequencyMagnitude = 0;
      let averageFirstFrequencyMagnitude = 0;
      let firstFrequencyMagnitudeVariance = 0;
      let firstFrequencyMagnitudes = new Array(
        FREQUENCY_MAGNITUDE_SAMPLES
      ).fill(0);

      let currentSecondFrequencyMagnitude = 0;
      let totalSecondFrequencyMagnitude = 0;
      let averageSecondFrequencyMagnitude = 0;
      let secondFrequencyMagnitudeVariance = 0;
      let secondFrequencyMagnitudes = new Array(
        FREQUENCY_MAGNITUDE_SAMPLES
      ).fill(0);

      let currentSignal = 0;
      let totalSignal = 0;
      let averageSignal = 0;
      let signalVariance = 0;
      let signals = new Array(FREQUENCY_MAGNITUDE_SAMPLES).fill(0);

      let lastBeatTimestamp = 0;
      let durationSinceLastBeat = 0;
      let beatProbability = 0;

      let lastBeatTimestampFirst = 0;
      let durationSinceLastBeatFirst = 0;
      let beatProbabilityFirst = 0;

      let lastBeatTimestampSecond = 0;
      let durationSinceLastBeatSecond = 0;
      let beatProbabilitySecond = 0;
      let beatProbabilityThresholdFirst = 0.5;
      let beatProbabilityThresholdSecond = 0.5;

      let lightIntensityBumpTimestamp = 0;
      let lightIntensityBumpValue = 0;
      let lightIntensityValue = 0;

      let lightIntensityBumpTimestampFirst = 0;
      let lightIntensityBumpValueFirst = 0;
      let lightIntensityValueFirst = 0;

      let lightIntensityBumpTimestampSecond = 0;
      let lightIntensityBumpValueSecond = 0;
      let lightIntensityValueSecond = 0;

      // UI Elements
      const startBtn = document.getElementById("startBtn");
      const stopBtn = document.getElementById("stopBtn");
      const status = document.getElementById("status");
      const consoleDiv = document.getElementById("console");
      const beatVisualizer = document.getElementById("beatVisualizer");
      const firstBeatVisualizer = document.getElementById(
        "firstBeatVisualizer"
      );
      const secondBeatVisualizer = document.getElementById(
        "secondBeatVisualizer"
      );
      const firstThresholdInput = document.getElementById("firstThreshold");
      const secondThresholdInput = document.getElementById("secondThreshold");

      // Event Listeners
      startBtn.addEventListener("click", start);
      stopBtn.addEventListener("click", stop);
      if (firstThresholdInput) {
        firstThresholdInput.addEventListener("input", (e) => {
          beatProbabilityThresholdFirst = parseFloat(e.target.value);
        });
      }
      if (secondThresholdInput) {
        secondThresholdInput.addEventListener("input", (e) => {
          beatProbabilityThresholdSecond = parseFloat(e.target.value);
        });
      }

      async function start() {
        try {
          audioContext = new (window.AudioContext ||
            window.webkitAudioContext)();
          analyser = audioContext.createAnalyser();
          analyser.fftSize = FFT_SIZE;
          analyser.smoothingTimeConstant = 0;

          const stream = await navigator.mediaDevices.getUserMedia({
            audio: true,
          });
          microphone = audioContext.createMediaStreamSource(stream);
          microphone.connect(analyser);

          dataArray = new Uint8Array(analyser.frequencyBinCount);

          startBtn.disabled = true;
          stopBtn.disabled = false;
          status.textContent = "Running...";
          status.style.color = "#0f0";

          log("Beat detection started");
          loop();
        } catch (error) {
          log("Error: " + error.message);
          status.textContent = "Error: " + error.message;
          status.style.color = "#f00";
        }
      }

      function stop() {
        if (animationId) {
          cancelAnimationFrame(animationId);
        }
        if (microphone) {
          microphone.disconnect();
          microphone.mediaStream.getTracks().forEach((track) => track.stop());
        }
        if (audioContext) {
          audioContext.close();
        }

        startBtn.disabled = false;
        stopBtn.disabled = true;
        status.textContent = "Stopped";
        status.style.color = "#ff0";

        log("Beat detection stopped");
      }

      function loop() {
        animationId = requestAnimationFrame(loop);

        readAudioSamples();
        getFrequencyData();
        processFrequencyData();
        updateBeatProbability();
        updateFirstBeatProbability();
        updateSecondBeatProbability();
        updateLightIntensityBasedOnBeats();
        updateLightIntensityBasedOnBeatsFirst();
        updateLightIntensityBasedOnBeatsSecond();
        updateVisuals();
      }

      function readAudioSamples() {
        analyser.getByteTimeDomainData(dataArray);

        let currentAverage = 0;
        let currentMaximum = 0;
        let currentMinimum = MAXIMUM_SIGNAL_VALUE;

        for (let i = 0; i < dataArray.length; i++) {
          const value = dataArray[i];
          currentMinimum = Math.min(currentMinimum, value);
          currentMaximum = Math.max(currentMaximum, value);
          currentAverage += value;
        }

        currentAverage /= dataArray.length;

        const signalDelta = currentMaximum - currentAverage;
        currentSignal = currentAverage + 2 * signalDelta;
        currentSignal = Math.max(
          0,
          Math.min(MAXIMUM_SIGNAL_VALUE, currentSignal)
        );

        processHistoryValues(signals, currentSignal, "signal");
      }

      function getFrequencyData() {
        analyser.getByteFrequencyData(dataArray);
      }

      function processFrequencyData() {
        processOverallFrequencyMagnitude();
        processFirstFrequencyMagnitude();
        processSecondFrequencyMagnitude();

        frequencyMagnitudeSampleIndex++;
        if (frequencyMagnitudeSampleIndex >= FREQUENCY_MAGNITUDE_SAMPLES) {
          frequencyMagnitudeSampleIndex = 0;
        }
      }

      function processOverallFrequencyMagnitude() {
        currentOverallFrequencyMagnitude = getFrequencyMagnitude(
          OVERALL_FREQUENCY_RANGE_START,
          OVERALL_FREQUENCY_RANGE_END
        );

        processHistoryValues(
          overallFrequencyMagnitudes,
          currentOverallFrequencyMagnitude,
          "overall"
        );
      }

      function processFirstFrequencyMagnitude() {
        currentFirstFrequencyMagnitude = getFrequencyMagnitude(
          FIRST_FREQUENCY_RANGE_START,
          FIRST_FREQUENCY_RANGE_END
        );

        processHistoryValues(
          firstFrequencyMagnitudes,
          currentFirstFrequencyMagnitude,
          "first"
        );
      }

      function processSecondFrequencyMagnitude() {
        currentSecondFrequencyMagnitude = getFrequencyMagnitude(
          SECOND_FREQUENCY_RANGE_START,
          SECOND_FREQUENCY_RANGE_END
        );

        processHistoryValues(
          secondFrequencyMagnitudes,
          currentSecondFrequencyMagnitude,
          "second"
        );
      }

      function getFrequencyMagnitude(startIndex, endIndex) {
        let total = 0;
        let maximum = 0;
        let minimum = MAXIMUM_SIGNAL_VALUE;

        for (let i = startIndex; i < endIndex && i < dataArray.length; i++) {
          const current = dataArray[i];
          total += current;
          maximum = Math.max(maximum, current);
          minimum = Math.min(minimum, current);
        }

        const average = total / (endIndex - startIndex);
        return average;
      }

      function processHistoryValues(history, current, type) {
        history[frequencyMagnitudeSampleIndex] = current;

        let total = 0;
        for (let i = 0; i < FREQUENCY_MAGNITUDE_SAMPLES; i++) {
          total += history[i];
        }
        const average = total / FREQUENCY_MAGNITUDE_SAMPLES;

        let squaredDifferenceSum = 0;
        for (let i = 0; i < FREQUENCY_MAGNITUDE_SAMPLES; i++) {
          squaredDifferenceSum += Math.pow(history[i] - average, 2);
        }
        const variance = squaredDifferenceSum / FREQUENCY_MAGNITUDE_SAMPLES;

        switch (type) {
          case "signal":
            totalSignal = total;
            averageSignal = average;
            signalVariance = variance;
            break;
          case "overall":
            totalOverallFrequencyMagnitude = total;
            averageOverallFrequencyMagnitude = average;
            overallFrequencyMagnitudeVariance = variance;
            break;
          case "first":
            totalFirstFrequencyMagnitude = total;
            averageFirstFrequencyMagnitude = average;
            firstFrequencyMagnitudeVariance = variance;
            break;
          case "second":
            totalSecondFrequencyMagnitude = total;
            averageSecondFrequencyMagnitude = average;
            secondFrequencyMagnitudeVariance = variance;
            break;
        }
      }

      function updateBeatProbability() {
        beatProbability = 1;
        const signalChangeFactor = calculateSignalChangeFactor();
        const magnitudeChangeFactor = calculateMagnitudeChangeFactor();
        const varianceFactor = calculateVarianceFactor();
        const recencyFactor = calculateRecencyFactor();

        beatProbability *= signalChangeFactor;
        beatProbability *= magnitudeChangeFactor;
        beatProbability *= varianceFactor;
        beatProbability *= recencyFactor;

        if (beatProbability >= BEAT_PROBABILITY_THRESHOLD) {
          lastBeatTimestamp = Date.now();
          durationSinceLastBeat = 0;
          onBeatDetected();
        }

        updateProgressBar("beatProbBar", beatProbability);
      }

      function calculateSignalChangeFactor() {
        let aboveAverageSignalFactor;
        if (averageSignal < 75 || currentSignal < 150) {
          aboveAverageSignalFactor = 0;
        } else {
          aboveAverageSignalFactor = currentSignal / averageSignal;
          aboveAverageSignalFactor = Math.max(
            0,
            Math.min(2, aboveAverageSignalFactor)
          );
        }

        updateProgressBar("signalChangeBar", aboveAverageSignalFactor / 2);
        return aboveAverageSignalFactor;
      }

      function calculateMagnitudeChangeFactor() {
        let changeThresholdFactor = 1.1;
        if (durationSinceLastBeat < 750) {
          changeThresholdFactor *= 0.95;
        } else if (durationSinceLastBeat > 1000) {
          changeThresholdFactor *= 1.05;
        }

        let aboveAverageOverallMagnitudeFactor =
          currentOverallFrequencyMagnitude / averageOverallFrequencyMagnitude;
        aboveAverageOverallMagnitudeFactor -= 1.05;
        aboveAverageOverallMagnitudeFactor *= 10;
        aboveAverageOverallMagnitudeFactor = Math.max(
          0,
          Math.min(1, aboveAverageOverallMagnitudeFactor)
        );

        let aboveAverageFirstMagnitudeFactor =
          currentFirstFrequencyMagnitude / averageFirstFrequencyMagnitude;
        aboveAverageFirstMagnitudeFactor -= 0.1;
        aboveAverageFirstMagnitudeFactor *= 1.5;
        aboveAverageFirstMagnitudeFactor = Math.pow(
          aboveAverageFirstMagnitudeFactor,
          3
        );
        aboveAverageFirstMagnitudeFactor /= 3;
        aboveAverageFirstMagnitudeFactor -= 1.25;
        aboveAverageFirstMagnitudeFactor = Math.max(
          0,
          Math.min(1, aboveAverageFirstMagnitudeFactor)
        );

        let aboveAverageSecondMagnitudeFactor =
          currentSecondFrequencyMagnitude / averageSecondFrequencyMagnitude;
        aboveAverageSecondMagnitudeFactor -= 1.01;
        aboveAverageSecondMagnitudeFactor *= 10;
        aboveAverageSecondMagnitudeFactor = Math.max(
          0,
          Math.min(1, aboveAverageSecondMagnitudeFactor)
        );

        let magnitudeChangeFactor = aboveAverageFirstMagnitudeFactor;
        if (magnitudeChangeFactor > 0.15) {
          magnitudeChangeFactor = Math.max(
            aboveAverageFirstMagnitudeFactor,
            aboveAverageSecondMagnitudeFactor
          );
        }

        if (
          magnitudeChangeFactor < 0.5 &&
          aboveAverageOverallMagnitudeFactor > 0.5
        ) {
          magnitudeChangeFactor = Math.max(
            magnitudeChangeFactor,
            aboveAverageOverallMagnitudeFactor
          );
        }

        updateProgressBar("magChangeBar", magnitudeChangeFactor);
        return magnitudeChangeFactor;
      }

      function calculateVarianceFactor() {
        let firstVarianceFactor =
          (firstFrequencyMagnitudeVariance - 50) / 20 - 1;
        firstVarianceFactor = Math.max(0, Math.min(1, firstVarianceFactor));

        let secondVarianceFactor =
          (secondFrequencyMagnitudeVariance - 50) / 20 - 1;
        secondVarianceFactor = Math.max(0, Math.min(1, secondVarianceFactor));

        const varianceFactor = Math.max(
          firstVarianceFactor,
          secondVarianceFactor
        );

        updateProgressBar("varianceBar", varianceFactor);
        return varianceFactor;
      }

      function calculateRecencyFactor() {
        durationSinceLastBeat = Date.now() - lastBeatTimestamp;

        const referenceDuration =
          MINIMUM_DELAY_BETWEEN_BEATS - SINGLE_BEAT_DURATION;
        let recencyFactor = 1 - referenceDuration / durationSinceLastBeat;
        recencyFactor = Math.max(0, Math.min(1, recencyFactor));

        return recencyFactor;
      }

      function calculateRecencyFactorFor(lastTimestamp) {
        const duration = Date.now() - lastTimestamp;
        const referenceDuration =
          MINIMUM_DELAY_BETWEEN_BEATS - SINGLE_BEAT_DURATION;
        let recencyFactor = 1 - referenceDuration / duration;
        recencyFactor = Math.max(0, Math.min(1, recencyFactor));
        return recencyFactor;
      }

      function updateFirstBeatProbability() {
        const magnitudeFirstFactor = calculateFirstMagnitudeFactor();
        const varianceFirstFactor = calculateFirstVarianceFactor();
        const recencyFirstFactor = calculateRecencyFactorFor(
          lastBeatTimestampFirst
        );

        beatProbabilityFirst =
          magnitudeFirstFactor * varianceFirstFactor * recencyFirstFactor;

        if (beatProbabilityFirst >= beatProbabilityThresholdFirst) {
          lastBeatTimestampFirst = Date.now();
          durationSinceLastBeatFirst = 0;
          onBeatDetectedFirst();
        }

        updateProgressBar("beatProbBarFirstSmall", beatProbabilityFirst);
      }

      function updateSecondBeatProbability() {
        const magnitudeSecondFactor = calculateSecondMagnitudeFactor();
        const varianceSecondFactor = calculateSecondVarianceFactor();
        const recencySecondFactor = calculateRecencyFactorFor(
          lastBeatTimestampSecond
        );

        beatProbabilitySecond =
          magnitudeSecondFactor * varianceSecondFactor * recencySecondFactor;

        if (beatProbabilitySecond >= beatProbabilityThresholdSecond) {
          lastBeatTimestampSecond = Date.now();
          durationSinceLastBeatSecond = 0;
          onBeatDetectedSecond();
        }

        updateProgressBar("beatProbBarSecondSmall", beatProbabilitySecond);
      }

      function calculateFirstMagnitudeFactor() {
        let aboveAverageFirstMagnitudeFactor =
          currentFirstFrequencyMagnitude / averageFirstFrequencyMagnitude;
        aboveAverageFirstMagnitudeFactor -= 0.1;
        aboveAverageFirstMagnitudeFactor *= 1.5;
        aboveAverageFirstMagnitudeFactor = Math.pow(
          aboveAverageFirstMagnitudeFactor,
          3
        );
        aboveAverageFirstMagnitudeFactor /= 3;
        aboveAverageFirstMagnitudeFactor -= 1.25;
        aboveAverageFirstMagnitudeFactor = Math.max(
          0,
          Math.min(1, aboveAverageFirstMagnitudeFactor)
        );
        return aboveAverageFirstMagnitudeFactor;
      }

      function calculateSecondMagnitudeFactor() {
        let aboveAverageSecondMagnitudeFactor =
          currentSecondFrequencyMagnitude / averageSecondFrequencyMagnitude;
        aboveAverageSecondMagnitudeFactor -= 1.01;
        aboveAverageSecondMagnitudeFactor *= 10;
        aboveAverageSecondMagnitudeFactor = Math.max(
          0,
          Math.min(1, aboveAverageSecondMagnitudeFactor)
        );
        return aboveAverageSecondMagnitudeFactor;
      }

      function calculateFirstVarianceFactor() {
        let firstVarianceFactor =
          (firstFrequencyMagnitudeVariance - 50) / 20 - 1;
        firstVarianceFactor = Math.max(0, Math.min(1, firstVarianceFactor));
        return firstVarianceFactor;
      }

      function calculateSecondVarianceFactor() {
        let secondVarianceFactor =
          (secondFrequencyMagnitudeVariance - 50) / 20 - 1;
        secondVarianceFactor = Math.max(0, Math.min(1, secondVarianceFactor));
        return secondVarianceFactor;
      }

      function updateLightIntensityBasedOnBeatsFirst() {
        durationSinceLastBeatFirst = Date.now() - lastBeatTimestampFirst;
        let intensity =
          1 - durationSinceLastBeatFirst / LIGHT_FADE_OUT_DURATION;
        intensity = Math.max(0, Math.min(1, intensity));

        if (intensity > lightIntensityValueFirst) {
          lightIntensityBumpValueFirst = intensity;
          lightIntensityBumpTimestampFirst = Date.now();
        }
      }

      function updateLightIntensityBasedOnBeatsSecond() {
        durationSinceLastBeatSecond = Date.now() - lastBeatTimestampSecond;
        let intensity =
          1 - durationSinceLastBeatSecond / LIGHT_FADE_OUT_DURATION;
        intensity = Math.max(0, Math.min(1, intensity));

        if (intensity > lightIntensityValueSecond) {
          lightIntensityBumpValueSecond = intensity;
          lightIntensityBumpTimestampSecond = Date.now();
        }
      }

      function updateLightIntensityBasedOnBeats() {
        let intensity = 1 - durationSinceLastBeat / LIGHT_FADE_OUT_DURATION;
        intensity = Math.max(0, Math.min(1, intensity));

        if (intensity > lightIntensityValue) {
          lightIntensityBumpValue = intensity;
          lightIntensityBumpTimestamp = Date.now();
        }
      }

      function updateVisuals() {
        const durationSinceLastBump = Date.now() - lightIntensityBumpTimestamp;
        let fadeFactor = 1 - durationSinceLastBump / LIGHT_FADE_OUT_DURATION;
        fadeFactor = Math.max(0, Math.min(1, fadeFactor));

        lightIntensityValue = lightIntensityBumpValue * fadeFactor;
        lightIntensityValue = Math.max(0, Math.min(1, lightIntensityValue));

        const scaledLightIntensity =
          MINIMUM_LIGHT_INTENSITY +
          lightIntensityValue *
            (MAXIMUM_LIGHT_INTENSITY - MINIMUM_LIGHT_INTENSITY);

        beatVisualizer.style.background = `radial-gradient(circle,
                rgba(0, ${Math.floor(
                  255 * scaledLightIntensity
                )}, 0, ${scaledLightIntensity}),
                #000000)`;
        beatVisualizer.style.boxShadow = `0 0 ${
          50 + scaledLightIntensity * 150
        }px rgba(0, 255, 0, ${scaledLightIntensity})`;

        // First band visualizer — beat-based fade (no baseline)
        const durationSinceLastBumpFirst =
          Date.now() - lightIntensityBumpTimestampFirst;
        let fadeFactorFirst =
          1 - durationSinceLastBumpFirst / LIGHT_FADE_OUT_DURATION;
        fadeFactorFirst = Math.max(0, Math.min(1, fadeFactorFirst));

        lightIntensityValueFirst =
          lightIntensityBumpValueFirst * fadeFactorFirst;
        lightIntensityValueFirst = Math.max(
          0,
          Math.min(1, lightIntensityValueFirst)
        );

        const scaledLightIntensityFirst = lightIntensityValueFirst;

        firstBeatVisualizer.style.background = `radial-gradient(circle,
                rgba(0, ${Math.floor(
                  255 * scaledLightIntensityFirst
                )}, ${Math.floor(
          255 * scaledLightIntensityFirst
        )}, ${scaledLightIntensityFirst}),
                #000000)`;
        firstBeatVisualizer.style.boxShadow = `0 0 ${
          30 + scaledLightIntensityFirst * 90
        }px rgba(0, 255, 255, ${scaledLightIntensityFirst})`;

        // Second band visualizer — beat-based fade (no baseline)
        const durationSinceLastBumpSecond =
          Date.now() - lightIntensityBumpTimestampSecond;
        let fadeFactorSecond =
          1 - durationSinceLastBumpSecond / LIGHT_FADE_OUT_DURATION;
        fadeFactorSecond = Math.max(0, Math.min(1, fadeFactorSecond));

        lightIntensityValueSecond =
          lightIntensityBumpValueSecond * fadeFactorSecond;
        lightIntensityValueSecond = Math.max(
          0,
          Math.min(1, lightIntensityValueSecond)
        );

        const scaledLightIntensitySecond = lightIntensityValueSecond;

        secondBeatVisualizer.style.background = `radial-gradient(circle,
                rgba(${Math.floor(
                  255 * scaledLightIntensitySecond
                )}, ${Math.floor(
          200 * scaledLightIntensitySecond
        )}, 0, ${scaledLightIntensitySecond}),
                #000000)`;
        secondBeatVisualizer.style.boxShadow = `0 0 ${
          30 + scaledLightIntensitySecond * 90
        }px rgba(255, 200, 0, ${scaledLightIntensitySecond})`;

        updateProgressBar("signalBar", currentSignal / MAXIMUM_SIGNAL_VALUE);
        updateProgressBar("lightBar", lightIntensityValue);
      }

      function onBeatDetected() {
        beatVisualizer.classList.add("beat");
        setTimeout(() => beatVisualizer.classList.remove("beat"), 100);
        log("BEAT DETECTED!");
      }

      function onBeatDetectedFirst() {
        firstBeatVisualizer.classList.add("beat");
        setTimeout(() => firstBeatVisualizer.classList.remove("beat"), 100);
        log("LOW-BAND BEAT!");
      }

      function onBeatDetectedSecond() {
        secondBeatVisualizer.classList.add("beat");
        setTimeout(() => secondBeatVisualizer.classList.remove("beat"), 100);
        log("MID-BAND BEAT!");
      }

      function updateProgressBar(id, value) {
        const bar = document.getElementById(id);
        if (bar) {
          bar.style.width = value * 100 + "%";
        }
      }

      function log(message) {
        const timestamp = new Date().toLocaleTimeString();
        consoleDiv.innerHTML += `[${timestamp}] ${message}<br>`;
        consoleDiv.scrollTop = consoleDiv.scrollHeight;
      }
    </script>
  </body>
</html>
